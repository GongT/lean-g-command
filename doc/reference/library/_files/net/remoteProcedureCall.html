"use strict";
var net = require('net');

var sconsole = new Logger('RPCServer');
var cconsole = new Logger('RPCClient');

/**
 *
 */
var clientLists = {};
module.exports.client = function (appId, leanId, port, callbackId){
	var p = new AV.Promise;
	var connectKey = appId + ':' + callbackId;
	var ok = false;
	var socket = clientLists[connectKey] = net.createConnection(port, '127.0.0.1');
	
	cconsole.log('Start - ', connectKey);
	socket.on('connect', function (){
		cconsole.log('connected: %s ,write callbackid %s to server', connectKey, callbackId);
		socket.write(new Buffer(callbackId + ' '));
	});
	var cache = '';
	socket.on('data', function (d){
		cconsole.log('server data:', d.toString());
		ok = true;
		
		cache += d.toString('utf8');
		var lines = cache.split('\n');
		if(lines[lines.length - 1]){
			cache = lines.pop();
		} else{
			cache = '';
		}
		var line = lines.join('\n');
		cconsole.log('Output %s: %s', connectKey, line);
		if(line.indexOf('OK') >= 0){
			p.resolve();
		} else if(line.indexOf('Error:')){
			p.reject(line);
		}
	});
	socket.on('end', function (){
		cconsole.log('Socket End:', connectKey);
	});
	socket.on('error', function (e){
		if(!ok){
			p.reject(ApiError.E_RPC.data(e));
		}
		cconsole.log('Socket Error:', connectKey, e);
	});
	socket.on('close', function (){
		cconsole.log('Socket Close:', connectKey);
	});
	
	p.then(function (){
		delete clientLists[connectKey];
	}, function (){
		delete clientLists[connectKey];
	});
	
	return p;
};

module.exports.createServer = function (appId, leanId){
	return new RPCServer(appId, leanId);
};
function RPCServer(appId, leanId){
	this.appId = appId;
	this.leanId = leanId;
	this.server = null;
	this.port = 0;
	this.stack = null;
	this.success = false;
	this.retry = 0;
	this.clients = {};
	this.callback = {};
	this._guid = 0;
}

RPCServer.prototype.getGuid = function (){
	if(this._guid > Number.MAX_VALUE/1000){
		this._guid = 0;
	}
	return 'item' + (++this._guid);
};

RPCServer.prototype.start = function (){
	if(this.server){
		return;
	}
	var self = this;
	var server = net.createServer(function (client){
		var guid = self.getGuid();
		self.clients[guid] = client;
		sconsole.log('client connected: ' + guid);
		client.on('end', function (){
			delete self.clients[guid];
			sconsole.log('client disconnected: ' + guid);
			client.destroy();
		});
		client.cache = '';
		client.on('data', function (d){
			sconsole.log('client data: ', d.toString());
			client.cache += d.toString();
			var cbname = client.cache.split(' ');
			if(cbname.length > 1){
				var cb = self.callback[cbname[0]];
				sconsole.log('run function: ', cbname[0]);
				if(cb){
					try{
						cb();
						client.write(new Buffer('OK\n'));
					} catch(e){
						client.write(new Buffer(e.stack + '\n'));
					}
				} else{
					sconsole.error('NO function: %s in [%s]', cbname[0], Object.keys(self.callback));
					client.write('Error: callback id ' + cbname[0] + ' NOT found.');
				}
			}
		});
	});
	server.listen(0, function (){
		self.port = server.address().port;
		sconsole.log('server port is ', self.port);
		
		self.registerPort();
	});
	
	this.server = server;
};

RPCServer.prototype.registerPort = function (){
	var retry = ++this.retry;
	var self = this;
	library.net.getAvServer('TaskHost').run('rpc::register', {
		appId : this.appId,
		leanId: this.leanId,
		port  : this.port
	}).then(function (res){
		sconsole.log('Register Success');
		self.success = true;
		if(self.stack){
			self.stack.forEach(self.run);
		}
		delete self.stack;
	}, function (e){
		if(retry > 5){
			sconsole.error('Fatal Register Error: ' + e.message);
			return;
		}
		self.success = false;
		sconsole.error('Register Error: ' + e.message);
		setTimeout(function (){
			self.registerPort();
		}, 2000);
	});
};

RPCServer.prototype.run = function (callback){
	if(this.success){
		var guid = this.getGuid();
		console.log('request call function %s', guid);
		var callbacks = this.callback;
		callbacks[guid] = callback;
		library.net.getAvServer('TaskHost').run('rpc::run', {
			appId : this.appId,
			leanId: this.leanId,
			port  : this.port,
			guid  : guid
		}).then(function (res){
			delete callbacks[guid];
			sconsole.info('do callback Success');
		}, function (e){
			delete callbacks[guid];
			sconsole.error('do callback Fail' + e.message);
		});
	} else{
		console.log('server not ok, queue request.');
		if(!this.stack){
			this.stack = [];
		}
		this.stack.push(callback);
	}
};
